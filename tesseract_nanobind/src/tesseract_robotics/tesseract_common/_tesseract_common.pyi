from collections.abc import Sequence
import enum
from typing import Annotated, overload

import numpy
from numpy.typing import NDArray


class Isometry3d:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, matrix: Annotated[NDArray[numpy.float64], dict(shape=(4, 4), order='F')]) -> None: ...

    @staticmethod
    def Identity() -> Isometry3d: ...

    def matrix(self) -> Annotated[NDArray[numpy.float64], dict(shape=(4, 4), order='F')]: ...

    def translation(self) -> Annotated[NDArray[numpy.float64], dict(shape=(3), order='C')]: ...

    def rotation(self) -> Annotated[NDArray[numpy.float64], dict(shape=(3, 3), order='F')]: ...

    def linear(self) -> Annotated[NDArray[numpy.float64], dict(shape=(3, 3), order='F')]: ...

    def inverse(self) -> Isometry3d: ...

    @overload
    def __mul__(self, arg: Isometry3d, /) -> Isometry3d: ...

    @overload
    def __mul__(self, arg: Translation3d, /) -> Isometry3d: ...

    @overload
    def __mul__(self, arg: Quaterniond, /) -> Isometry3d: ...

    @overload
    def __mul__(self, arg: AngleAxisd, /) -> Isometry3d: ...

    @overload
    def __mul__(self, arg: Annotated[NDArray[numpy.float64], dict(shape=(3), order='C')], /) -> Annotated[NDArray[numpy.float64], dict(shape=(3), order='C')]: ...

class Translation3d:
    def __init__(self, arg0: float, arg1: float, arg2: float, /) -> None: ...

    @overload
    def __mul__(self, arg: Isometry3d, /) -> Isometry3d: ...

    @overload
    def __mul__(self, arg: Translation3d, /) -> Translation3d: ...

class Quaterniond:
    @overload
    def __init__(self, arg0: float, arg1: float, arg2: float, arg3: float, /) -> None: ...

    @overload
    def __init__(self, rotation_matrix: Annotated[NDArray[numpy.float64], dict(shape=(3, 3), order='F')]) -> None: ...

    def w(self) -> float: ...

    def x(self) -> float: ...

    def y(self) -> float: ...

    def z(self) -> float: ...

    def toRotationMatrix(self) -> Annotated[NDArray[numpy.float64], dict(shape=(3, 3), order='F')]: ...

class AngleAxisd:
    def __init__(self, arg0: float, arg1: Annotated[NDArray[numpy.float64], dict(shape=(3), order='C')], /) -> None: ...

    def toRotationMatrix(self) -> Annotated[NDArray[numpy.float64], dict(shape=(3, 3), order='F')]: ...

class FilesystemPath:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, path: str) -> None: ...

    def string(self) -> str: ...

    def __str__(self) -> str: ...

    def __repr__(self) -> str: ...

class Resource:
    def isFile(self) -> bool: ...

    def getUrl(self) -> str: ...

    def getFilePath(self) -> str: ...

    def getResourceContents(self) -> bytes: ...

    def getResourceContentStream(self) -> "std::__1::basic_istream<char, std::__1::char_traits<char>>": ...

class BytesResource(Resource):
    @overload
    def __init__(self, arg0: str, arg1: Sequence[int], /) -> None: ...

    @overload
    def __init__(self, arg0: str, arg1: bytes, /) -> None: ...

class SimpleLocatedResource(Resource):
    @overload
    def __init__(self, url: str, filename: str) -> None: ...

    @overload
    def __init__(self, url: str, filename: str, parent: ResourceLocator) -> None: ...

class ResourceLocator:
    def __init__(self) -> None: ...

    def locateResource(self, arg: str, /) -> Resource: ...

class GeneralResourceLocator(ResourceLocator):
    def __init__(self) -> None: ...

class ManipulatorInfo:
    def __init__(self) -> None: ...

    @property
    def manipulator(self) -> str: ...

    @manipulator.setter
    def manipulator(self, arg: str, /) -> None: ...

    @property
    def manipulator_ik_solver(self) -> str: ...

    @manipulator_ik_solver.setter
    def manipulator_ik_solver(self, arg: str, /) -> None: ...

    @property
    def working_frame(self) -> str: ...

    @working_frame.setter
    def working_frame(self, arg: str, /) -> None: ...

    @property
    def tcp_frame(self) -> str: ...

    @tcp_frame.setter
    def tcp_frame(self, arg: str, /) -> None: ...

    @property
    def tcp_offset(self) -> object: ...

    @tcp_offset.setter
    def tcp_offset(self, arg: object, /) -> None: ...

    def __repr__(self) -> str: ...

class JointState:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, arg0: Sequence[str], arg1: Annotated[NDArray[numpy.float64], dict(shape=(None,), order='C')], /) -> None: ...

    @property
    def joint_names(self) -> list[str]: ...

    @joint_names.setter
    def joint_names(self, arg: Sequence[str], /) -> None: ...

    @property
    def position(self) -> Annotated[NDArray[numpy.float64], dict(shape=(None,), order='C')]: ...

    @position.setter
    def position(self, arg: Annotated[NDArray[numpy.float64], dict(shape=(None,), order='C')], /) -> None: ...

    @property
    def velocity(self) -> Annotated[NDArray[numpy.float64], dict(shape=(None,), order='C')]: ...

    @velocity.setter
    def velocity(self, arg: Annotated[NDArray[numpy.float64], dict(shape=(None,), order='C')], /) -> None: ...

    @property
    def acceleration(self) -> Annotated[NDArray[numpy.float64], dict(shape=(None,), order='C')]: ...

    @acceleration.setter
    def acceleration(self, arg: Annotated[NDArray[numpy.float64], dict(shape=(None,), order='C')], /) -> None: ...

    @property
    def effort(self) -> Annotated[NDArray[numpy.float64], dict(shape=(None,), order='C')]: ...

    @effort.setter
    def effort(self, arg: Annotated[NDArray[numpy.float64], dict(shape=(None,), order='C')], /) -> None: ...

    @property
    def time(self) -> float: ...

    @time.setter
    def time(self, arg: float, /) -> None: ...

class AllowedCollisionMatrix:
    def __init__(self) -> None: ...

    def addAllowedCollision(self, arg0: str, arg1: str, arg2: str, /) -> None: ...

    def removeAllowedCollision(self, arg0: str, arg1: str, /) -> None: ...

    def isCollisionAllowed(self, arg0: str, arg1: str, /) -> bool: ...

    def clearAllowedCollisions(self) -> None: ...

    def getAllAllowedCollisions(self) -> dict[tuple[str, str], str]: ...

    def insertAllowedCollisionMatrix(self, arg: AllowedCollisionMatrix, /) -> None: ...

class CollisionMarginOverrideType(enum.Enum):
    NONE = 0

    REPLACE = 1

    MODIFY = 2

    OVERRIDE_DEFAULT_MARGIN = 3

    OVERRIDE_PAIR_MARGIN = 4

    MODIFY_PAIR_MARGIN = 5

class CollisionMarginData:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, arg: float, /) -> None: ...

    def getDefaultCollisionMargin(self) -> float: ...

    def setDefaultCollisionMargin(self, arg: float, /) -> None: ...

    def getPairCollisionMargin(self, arg0: str, arg1: str, /) -> float: ...

    def setPairCollisionMargin(self, arg0: str, arg1: str, arg2: float, /) -> None: ...

    def getMaxCollisionMargin(self) -> float: ...

class KinematicLimits:
    def __init__(self) -> None: ...

    @property
    def joint_limits(self) -> Annotated[NDArray[numpy.float64], dict(shape=(None, 2), order='F')]: ...

    @joint_limits.setter
    def joint_limits(self, arg: Annotated[NDArray[numpy.float64], dict(shape=(None, 2), order='F')], /) -> None: ...

    @property
    def velocity_limits(self) -> Annotated[NDArray[numpy.float64], dict(shape=(None, 2), order='F')]: ...

    @velocity_limits.setter
    def velocity_limits(self, arg: Annotated[NDArray[numpy.float64], dict(shape=(None, 2), order='F')], /) -> None: ...

    @property
    def acceleration_limits(self) -> Annotated[NDArray[numpy.float64], dict(shape=(None, 2), order='F')]: ...

    @acceleration_limits.setter
    def acceleration_limits(self, arg: Annotated[NDArray[numpy.float64], dict(shape=(None, 2), order='F')], /) -> None: ...

class PluginInfo:
    def __init__(self) -> None: ...

    @property
    def class_name(self) -> str: ...

    @class_name.setter
    def class_name(self, arg: str, /) -> None: ...

    @property
    def config(self) -> "YAML::Node": ...

    @config.setter
    def config(self, arg: "YAML::Node", /) -> None: ...

class LogLevel(enum.Enum):
    CONSOLE_BRIDGE_LOG_DEBUG = 0

    CONSOLE_BRIDGE_LOG_INFO = 1

    CONSOLE_BRIDGE_LOG_WARN = 2

    CONSOLE_BRIDGE_LOG_ERROR = 3

    CONSOLE_BRIDGE_LOG_NONE = 4

CONSOLE_BRIDGE_LOG_DEBUG: LogLevel = LogLevel.CONSOLE_BRIDGE_LOG_DEBUG

CONSOLE_BRIDGE_LOG_INFO: LogLevel = LogLevel.CONSOLE_BRIDGE_LOG_INFO

CONSOLE_BRIDGE_LOG_WARN: LogLevel = LogLevel.CONSOLE_BRIDGE_LOG_WARN

CONSOLE_BRIDGE_LOG_ERROR: LogLevel = LogLevel.CONSOLE_BRIDGE_LOG_ERROR

CONSOLE_BRIDGE_LOG_NONE: LogLevel = LogLevel.CONSOLE_BRIDGE_LOG_NONE

class OutputHandler:
    def __init__(self) -> None: ...

    def log(self, arg0: str, arg1: LogLevel, arg2: str, arg3: int, /) -> None: ...

def setLogLevel(level: LogLevel) -> None: ...

def getLogLevel() -> LogLevel: ...

def log(filename: str, line: int, level: LogLevel, msg: str) -> None: ...

def useOutputHandler(handler: OutputHandler) -> None: ...

def restorePreviousOutputHandler() -> None: ...

class VectorVector3d:
    def __init__(self) -> None: ...

    def __len__(self) -> int: ...

    def __getitem__(self, arg: int, /) -> Annotated[NDArray[numpy.float64], dict(shape=(3), order='C')]: ...

    def __setitem__(self, arg0: int, arg1: Annotated[NDArray[numpy.float64], dict(shape=(3), order='C')], /) -> None: ...

    def append(self, arg: Annotated[NDArray[numpy.float64], dict(shape=(3), order='C')], /) -> None: ...

    def clear(self) -> None: ...

class VectorIsometry3d:
    def __init__(self) -> None: ...

    def __len__(self) -> int: ...

    def __getitem__(self, arg: int, /) -> Isometry3d: ...

    def append(self, arg: Isometry3d, /) -> None: ...

    def clear(self) -> None: ...
