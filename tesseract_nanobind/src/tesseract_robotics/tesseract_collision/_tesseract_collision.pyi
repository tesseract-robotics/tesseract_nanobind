import enum
from collections.abc import Mapping, Sequence
from typing import Annotated, overload

import numpy
from numpy.typing import NDArray

class ContinuousCollisionType(enum.Enum):
    CCType_None = 0

    CCType_Time0 = 1

    CCType_Time1 = 2

    CCType_Between = 3

class ContactTestType(enum.Enum):
    FIRST = 0

    CLOSEST = 1

    ALL = 2

    LIMITED = 3

ContactTestType_FIRST: ContactTestType = ContactTestType.FIRST

ContactTestType_CLOSEST: ContactTestType = ContactTestType.CLOSEST

ContactTestType_ALL: ContactTestType = ContactTestType.ALL

ContactTestType_LIMITED: ContactTestType = ContactTestType.LIMITED

class CollisionEvaluatorType(enum.Enum):
    NONE = 0

    DISCRETE = 1

    LVS_DISCRETE = 2

    CONTINUOUS = 3

    LVS_CONTINUOUS = 4

class CollisionCheckProgramType(enum.Enum):
    ALL = 0

    ALL_EXCEPT_START = 1

    ALL_EXCEPT_END = 2

    START_ONLY = 3

    END_ONLY = 4

    INTERMEDIATE_ONLY = 5

class ACMOverrideType(enum.Enum):
    NONE = 0

    ASSIGN = 1

    AND = 2

    OR = 3

class ContactResult:
    def __init__(self) -> None: ...
    @property
    def distance(self) -> float: ...
    @distance.setter
    def distance(self, arg: float, /) -> None: ...
    @property
    def type_id(self) -> list[int]: ...
    @type_id.setter
    def type_id(self, arg: Sequence[int], /) -> None: ...
    @property
    def link_names(self) -> list[str]: ...
    @link_names.setter
    def link_names(self, arg: Sequence[str], /) -> None: ...
    @property
    def shape_id(self) -> list[int]: ...
    @shape_id.setter
    def shape_id(self, arg: Sequence[int], /) -> None: ...
    @property
    def nearest_points(
        self,
    ) -> list[Annotated[NDArray[numpy.float64], dict(shape=(3), order="C")]]: ...
    @nearest_points.setter
    def nearest_points(
        self, arg: Sequence[Annotated[NDArray[numpy.float64], dict(shape=(3), order="C")]], /
    ) -> None: ...
    @property
    def transform(self) -> list["Eigen::Transform<double, 3, 1, 0>"]: ...
    @transform.setter
    def transform(self, arg: Sequence["Eigen::Transform<double, 3, 1, 0>"], /) -> None: ...
    @property
    def normal(self) -> Annotated[NDArray[numpy.float64], dict(shape=(3), order="C")]: ...
    @normal.setter
    def normal(
        self, arg: Annotated[NDArray[numpy.float64], dict(shape=(3), order="C")], /
    ) -> None: ...
    @property
    def single_contact_point(self) -> bool: ...
    @single_contact_point.setter
    def single_contact_point(self, arg: bool, /) -> None: ...
    def clear(self) -> None: ...

class ContactResultVector:
    def __init__(self) -> None: ...
    def __len__(self) -> int: ...
    def __getitem__(self, arg: int, /) -> ContactResult: ...
    def append(self, arg: ContactResult, /) -> None: ...
    def clear(self) -> None: ...

class ContactResultMap:
    def __init__(self) -> None: ...
    def count(self) -> int: ...
    def size(self) -> int: ...
    def empty(self) -> bool: ...
    def clear(self) -> None: ...
    def release(self) -> None: ...
    def getSummary(self) -> str: ...
    def flattenCopyResults(self) -> ContactResultVector: ...
    def flattenMoveResults(self, results: ContactResultVector) -> None: ...
    def __len__(self) -> int: ...

class ContactRequest:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, type: ContactTestType) -> None: ...
    @property
    def type(self) -> ContactTestType: ...
    @type.setter
    def type(self, arg: ContactTestType, /) -> None: ...
    @property
    def calculate_penetration(self) -> bool: ...
    @calculate_penetration.setter
    def calculate_penetration(self, arg: bool, /) -> None: ...
    @property
    def calculate_distance(self) -> bool: ...
    @calculate_distance.setter
    def calculate_distance(self, arg: bool, /) -> None: ...
    @property
    def contact_limit(self) -> int: ...
    @contact_limit.setter
    def contact_limit(self, arg: int, /) -> None: ...

class ContactManagerConfig:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, default_margin: float) -> None: ...
    @property
    def margin_data_override_type(self) -> "tesseract_common::CollisionMarginOverrideType": ...
    @margin_data_override_type.setter
    def margin_data_override_type(
        self, arg: "tesseract_common::CollisionMarginOverrideType", /
    ) -> None: ...
    @property
    def acm_override_type(self) -> ACMOverrideType: ...
    @acm_override_type.setter
    def acm_override_type(self, arg: ACMOverrideType, /) -> None: ...

class CollisionCheckConfig:
    def __init__(self) -> None: ...
    @property
    def contact_request(self) -> ContactRequest: ...
    @contact_request.setter
    def contact_request(self, arg: ContactRequest, /) -> None: ...
    @property
    def type(self) -> CollisionEvaluatorType: ...
    @type.setter
    def type(self, arg: CollisionEvaluatorType, /) -> None: ...
    @property
    def longest_valid_segment_length(self) -> float: ...
    @longest_valid_segment_length.setter
    def longest_valid_segment_length(self, arg: float, /) -> None: ...
    @property
    def check_program_mode(self) -> CollisionCheckProgramType: ...
    @check_program_mode.setter
    def check_program_mode(self, arg: CollisionCheckProgramType, /) -> None: ...

class DiscreteContactManager:
    def getName(self) -> str: ...
    def hasCollisionObject(self, name: str) -> bool: ...
    def removeCollisionObject(self, name: str) -> bool: ...
    def enableCollisionObject(self, name: str) -> bool: ...
    def disableCollisionObject(self, name: str) -> bool: ...
    def isCollisionObjectEnabled(self, name: str) -> bool: ...
    @overload
    def setCollisionObjectsTransform(
        self, name: str, pose: "Eigen::Transform<double, 3, 1, 0>"
    ) -> None: ...
    @overload
    def setCollisionObjectsTransform(
        self, transforms: Mapping[str, "Eigen::Transform<double, 3, 1, 0>"]
    ) -> None: ...
    @overload
    def setCollisionObjectsTransform(
        self, transforms: Mapping[str, "Eigen::Transform<double, 3, 1, 0>"]
    ) -> None: ...
    def getCollisionObjects(self) -> list[str]: ...
    def setActiveCollisionObjects(self, names: Sequence[str]) -> None: ...
    def getActiveCollisionObjects(self) -> list[str]: ...
    def setDefaultCollisionMarginData(self, default_collision_margin: float) -> None: ...
    def setPairCollisionMarginData(
        self, name1: str, name2: str, collision_margin: float
    ) -> None: ...
    def setCollisionMarginData(
        self, collision_margin_data: "tesseract_common::CollisionMarginData"
    ) -> None: ...
    def getCollisionMarginData(self) -> "tesseract_common::CollisionMarginData": ...
    def addCollisionObject(
        self,
        name: str,
        mask_id: int,
        shapes: Sequence["tesseract_geometry::Geometry"],
        shape_poses: Sequence["Eigen::Transform<double, 3, 1, 0>"],
        enabled: bool = True,
    ) -> bool: ...
    def getCollisionObjectGeometries(self, name: str) -> list["tesseract_geometry::Geometry"]: ...
    def getCollisionObjectGeometriesTransforms(
        self, name: str
    ) -> list["Eigen::Transform<double, 3, 1, 0>"]: ...
    def contactTest(self, collisions: ContactResultMap, request: ContactRequest) -> None: ...

class ContinuousContactManager:
    def getName(self) -> str: ...
    def hasCollisionObject(self, name: str) -> bool: ...
    def removeCollisionObject(self, name: str) -> bool: ...
    def enableCollisionObject(self, name: str) -> bool: ...
    def disableCollisionObject(self, name: str) -> bool: ...
    def isCollisionObjectEnabled(self, name: str) -> bool: ...
    def setCollisionObjectsTransform(
        self, name: str, pose: "Eigen::Transform<double, 3, 1, 0>"
    ) -> None: ...
    def setCollisionObjectsTransformCast(
        self,
        name: str,
        pose1: "Eigen::Transform<double, 3, 1, 0>",
        pose2: "Eigen::Transform<double, 3, 1, 0>",
    ) -> None: ...
    def getCollisionObjects(self) -> list[str]: ...
    def setActiveCollisionObjects(self, names: Sequence[str]) -> None: ...
    def getActiveCollisionObjects(self) -> list[str]: ...
    def setDefaultCollisionMarginData(self, default_collision_margin: float) -> None: ...
    def setPairCollisionMarginData(
        self, name1: str, name2: str, collision_margin: float
    ) -> None: ...
    def contactTest(self, collisions: ContactResultMap, request: ContactRequest) -> None: ...

class ContactManagersPluginFactory:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(
        self, config_path: "boost::filesystem::path", locator: "tesseract_common::ResourceLocator"
    ) -> None: ...
    @overload
    def __init__(self, config: str, locator: "tesseract_common::ResourceLocator") -> None: ...
    def addSearchPath(self, path: str) -> None: ...
    def getSearchPaths(self) -> set[str]: ...
    def addSearchLibrary(self, library_name: str) -> None: ...
    def getSearchLibraries(self) -> set[str]: ...
    def hasDiscreteContactManagerPlugins(self) -> bool: ...
    def getDefaultDiscreteContactManagerPlugin(self) -> str: ...
    def hasContinuousContactManagerPlugins(self) -> bool: ...
    def getDefaultContinuousContactManagerPlugin(self) -> str: ...
    def createDiscreteContactManager(self, name: str) -> DiscreteContactManager: ...
    def createContinuousContactManager(self, name: str) -> ContinuousContactManager: ...

def makeConvexMesh(mesh: "tesseract_geometry::Mesh") -> "tesseract_geometry::ConvexMesh":
    """Create a ConvexMesh from a Mesh using bullet's convex hull algorithm"""
