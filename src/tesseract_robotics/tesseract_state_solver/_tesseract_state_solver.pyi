from collections.abc import Mapping, Sequence
from typing import Annotated, overload

import numpy
from numpy.typing import NDArray


class SceneState:
    def __init__(self) -> None: ...

    @property
    def joints(self) -> dict[str, float]: ...

    @joints.setter
    def joints(self, arg: Mapping[str, float], /) -> None: ...

    @property
    def link_transforms(self) -> dict[str, "Eigen::Transform<double, 3, 1, 0>"]: ...

    @link_transforms.setter
    def link_transforms(self, arg: Mapping[str, "Eigen::Transform<double, 3, 1, 0>"], /) -> None: ...

    @property
    def joint_transforms(self) -> dict[str, "Eigen::Transform<double, 3, 1, 0>"]: ...

    @joint_transforms.setter
    def joint_transforms(self, arg: Mapping[str, "Eigen::Transform<double, 3, 1, 0>"], /) -> None: ...

    def getJointValues(self, joint_names: Sequence[str]) -> Annotated[NDArray[numpy.float64], dict(shape=(None,), order='C')]: ...

class StateSolver:
    @overload
    def getState(self) -> SceneState: ...

    @overload
    def getState(self, joint_values: Annotated[NDArray[numpy.float64], dict(shape=(None,), writable=False)]) -> SceneState: ...

    @overload
    def getState(self, joint_values: Mapping[str, float]) -> SceneState: ...

    @overload
    def getState(self, joint_names: Sequence[str], joint_values: Annotated[NDArray[numpy.float64], dict(shape=(None,), writable=False)]) -> SceneState: ...

    def getRandomState(self) -> SceneState: ...

    def setState(self, joint_values: Annotated[NDArray[numpy.float64], dict(shape=(None,), writable=False)]) -> None: ...

    def setStateByMap(self, joint_values: Mapping[str, float]) -> None: ...

    def setStateByNamesAndValues(self, joint_names: Sequence[str], joint_values: Annotated[NDArray[numpy.float64], dict(shape=(None,), writable=False)]) -> None: ...

    def getJacobian(self, joint_values: Annotated[NDArray[numpy.float64], dict(shape=(None,), writable=False)], link_name: str) -> Annotated[NDArray[numpy.float64], dict(shape=(None, None), order='F')]: ...

    def getJointNames(self) -> list[str]: ...

    def getFloatingJointNames(self) -> list[str]: ...

    def getActiveJointNames(self) -> list[str]: ...

    def getBaseLinkName(self) -> str: ...

    def getLinkNames(self) -> list[str]: ...

    def getActiveLinkNames(self) -> list[str]: ...

    def getStaticLinkNames(self) -> list[str]: ...

    def isActiveLinkName(self, link_name: str) -> bool: ...

    def hasLinkName(self, link_name: str) -> bool: ...

    def getLinkTransform(self, link_name: str) -> "Eigen::Transform<double, 3, 1, 0>": ...

    def getRelativeLinkTransform(self, from_link_name: str, to_link_name: str) -> "Eigen::Transform<double, 3, 1, 0>": ...

    def getLimits(self) -> "tesseract_common::KinematicLimits": ...

class MutableStateSolver(StateSolver):
    def setRevision(self, revision: int) -> None: ...

    def getRevision(self) -> int: ...

    def addLink(self, link: "tesseract_scene_graph::Link", joint: "tesseract_scene_graph::Joint") -> bool: ...

    def moveLink(self, joint: "tesseract_scene_graph::Joint") -> bool: ...

    def removeLink(self, name: str) -> bool: ...

    def replaceJoint(self, joint: "tesseract_scene_graph::Joint") -> bool: ...

    def removeJoint(self, name: str) -> bool: ...

    def moveJoint(self, name: str, parent_link: str) -> bool: ...

    def changeJointOrigin(self, name: str, new_origin: "Eigen::Transform<double, 3, 1, 0>") -> bool: ...

    def changeJointPositionLimits(self, name: str, lower: float, upper: float) -> bool: ...

    def changeJointVelocityLimits(self, name: str, limit: float) -> bool: ...

    def changeJointAccelerationLimits(self, name: str, limit: float) -> bool: ...

    def changeJointJerkLimits(self, name: str, limit: float) -> bool: ...

class KDLStateSolver(StateSolver):
    def __init__(self, scene_graph: "tesseract_scene_graph::SceneGraph") -> None: ...

    def clone(self) -> StateSolver: ...

class OFKTStateSolver(MutableStateSolver):
    def __init__(self, scene_graph: "tesseract_scene_graph::SceneGraph") -> None: ...

    def clone(self) -> StateSolver: ...
