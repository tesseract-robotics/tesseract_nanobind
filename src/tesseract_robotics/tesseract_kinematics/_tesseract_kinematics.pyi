from collections.abc import Mapping, Sequence
from typing import Annotated, overload

import numpy
from numpy.typing import NDArray


class URParameters:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, d1: float, a2: float, a3: float, d4: float, d5: float, d6: float) -> None: ...

    @property
    def d1(self) -> float: ...

    @d1.setter
    def d1(self, arg: float, /) -> None: ...

    @property
    def a2(self) -> float: ...

    @a2.setter
    def a2(self, arg: float, /) -> None: ...

    @property
    def a3(self) -> float: ...

    @a3.setter
    def a3(self, arg: float, /) -> None: ...

    @property
    def d4(self) -> float: ...

    @d4.setter
    def d4(self, arg: float, /) -> None: ...

    @property
    def d5(self) -> float: ...

    @d5.setter
    def d5(self, arg: float, /) -> None: ...

    @property
    def d6(self) -> float: ...

    @d6.setter
    def d6(self, arg: float, /) -> None: ...

UR10Parameters: URParameters = ...

UR5Parameters: URParameters = ...

UR3Parameters: URParameters = ...

UR10eParameters: URParameters = ...

UR5eParameters: URParameters = ...

UR3eParameters: URParameters = ...

class KinGroupIKInput:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, pose: "Eigen::Transform<double, 3, 1, 0>", working_frame: str, tip_link_name: str) -> None: ...

    @property
    def pose(self) -> "Eigen::Transform<double, 3, 1, 0>": ...

    @pose.setter
    def pose(self, arg: "Eigen::Transform<double, 3, 1, 0>", /) -> None: ...

    @property
    def working_frame(self) -> str: ...

    @working_frame.setter
    def working_frame(self, arg: str, /) -> None: ...

    @property
    def tip_link_name(self) -> str: ...

    @tip_link_name.setter
    def tip_link_name(self, arg: str, /) -> None: ...

class KinGroupIKInputs:
    def __init__(self) -> None: ...

    def __len__(self) -> int: ...

    def __getitem__(self, arg: int, /) -> KinGroupIKInput: ...

    def append(self, arg: KinGroupIKInput, /) -> None: ...

    def clear(self) -> None: ...

class ForwardKinematics:
    def calcFwdKin(self, joint_angles: Annotated[NDArray[numpy.float64], dict(shape=(None,), writable=False)]) -> dict[str, "Eigen::Transform<double, 3, 1, 0>"]: ...

    def calcJacobian(self, joint_angles: Annotated[NDArray[numpy.float64], dict(shape=(None,), writable=False)], link_name: str) -> Annotated[NDArray[numpy.float64], dict(shape=(None, None), order='F')]: ...

    def getBaseLinkName(self) -> str: ...

    def getJointNames(self) -> list[str]: ...

    def getTipLinkNames(self) -> list[str]: ...

    def numJoints(self) -> int: ...

    def getSolverName(self) -> str: ...

    def clone(self) -> ForwardKinematics: ...

class InverseKinematics:
    def calcInvKin(self, tip_link_poses: Mapping[str, "Eigen::Transform<double, 3, 1, 0>"], seed: Annotated[NDArray[numpy.float64], dict(shape=(None,), writable=False)]) -> list[Annotated[NDArray[numpy.float64], dict(shape=(None,), order='C')]]: ...

    def getJointNames(self) -> list[str]: ...

    def numJoints(self) -> int: ...

    def getBaseLinkName(self) -> str: ...

    def getWorkingFrame(self) -> str: ...

    def getTipLinkNames(self) -> list[str]: ...

    def getSolverName(self) -> str: ...

    def clone(self) -> InverseKinematics: ...

class JointGroup:
    def __init__(self, name: str, joint_names: Sequence[str], scene_graph: "tesseract_scene_graph::SceneGraph", scene_state: "tesseract_scene_graph::SceneState") -> None: ...

    def calcFwdKin(self, joint_angles: Annotated[NDArray[numpy.float64], dict(shape=(None,), writable=False)]) -> dict[str, "Eigen::Transform<double, 3, 1, 0>"]: ...

    def calcJacobian(self, joint_angles: Annotated[NDArray[numpy.float64], dict(shape=(None,), writable=False)], link_name: str) -> Annotated[NDArray[numpy.float64], dict(shape=(None, None), order='F')]: ...

    def calcJacobianWithPoint(self, joint_angles: Annotated[NDArray[numpy.float64], dict(shape=(None,), writable=False)], link_name: str, link_point: Annotated[NDArray[numpy.float64], dict(shape=(3), order='C')]) -> Annotated[NDArray[numpy.float64], dict(shape=(None, None), order='F')]: ...

    def getJointNames(self) -> list[str]: ...

    def getLinkNames(self) -> list[str]: ...

    def getActiveLinkNames(self) -> list[str]: ...

    def getStaticLinkNames(self) -> list[str]: ...

    def isActiveLinkName(self, link_name: str) -> bool: ...

    def hasLinkName(self, link_name: str) -> bool: ...

    def getLimits(self) -> "tesseract_common::KinematicLimits": ...

    def setLimits(self, limits: "tesseract_common::KinematicLimits") -> None: ...

    def getRedundancyCapableJointIndices(self) -> list[int]: ...

    def numJoints(self) -> int: ...

    def getBaseLinkName(self) -> str: ...

    def getName(self) -> str: ...

    def checkJoints(self, vec: Annotated[NDArray[numpy.float64], dict(shape=(None,), writable=False)]) -> bool: ...

class KinematicGroup(JointGroup):
    @overload
    def calcInvKin(self, tip_link_pose: KinGroupIKInput, seed: Annotated[NDArray[numpy.float64], dict(shape=(None,), writable=False)]) -> list[Annotated[NDArray[numpy.float64], dict(shape=(None,), order='C')]]: ...

    @overload
    def calcInvKin(self, tip_link_poses: KinGroupIKInputs, seed: Annotated[NDArray[numpy.float64], dict(shape=(None,), writable=False)]) -> list[Annotated[NDArray[numpy.float64], dict(shape=(None,), order='C')]]: ...

    def calcInvKinMultiple(self, tip_link_poses: Sequence[KinGroupIKInput], seed: Annotated[NDArray[numpy.float64], dict(shape=(None,), writable=False)]) -> list[Annotated[NDArray[numpy.float64], dict(shape=(None,), order='C')]]: ...

    def getAllValidWorkingFrames(self) -> list[str]: ...

    def getAllPossibleTipLinkNames(self) -> list[str]: ...

    def getInverseKinematics(self) -> InverseKinematics: ...

class KinematicsPluginFactory:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, config_path: "std::__1::__fs::filesystem::path", locator: "tesseract_common::ResourceLocator") -> None: ...

    @overload
    def __init__(self, config: str, locator: "tesseract_common::ResourceLocator") -> None: ...

    def addSearchPath(self, path: str) -> None: ...

    def getSearchPaths(self) -> list[str]: ...

    def addSearchLibrary(self, library_name: str) -> None: ...

    def getSearchLibraries(self) -> list[str]: ...

    def getDefaultFwdKinPlugin(self, group_name: str) -> str: ...

    def getDefaultInvKinPlugin(self, group_name: str) -> str: ...

    def createFwdKin(self, group_name: str, solver_name: str, scene_graph: "tesseract_scene_graph::SceneGraph", scene_state: "tesseract_scene_graph::SceneState") -> ForwardKinematics: ...

    def createInvKin(self, group_name: str, solver_name: str, scene_graph: "tesseract_scene_graph::SceneGraph", scene_state: "tesseract_scene_graph::SceneState") -> InverseKinematics: ...

def getRedundantSolutions(sol: Annotated[NDArray[numpy.float64], dict(shape=(None,), writable=False)], limits: Annotated[NDArray[numpy.float64], dict(shape=(None, 2), writable=False)], redundancy_capable_joints: Sequence[int]) -> list[Annotated[NDArray[numpy.float64], dict(shape=(None,), order='C')]]:
    """
    Get redundant solutions for a joint configuration by adding +/- 2*pi to redundancy capable joints
    """
